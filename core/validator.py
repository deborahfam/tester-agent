"""
validator.py
~~~~~~~~~~~~~

This module provides functions to validate candidate solutions by executing
them on a battery of test cases.  It relies on the ``sandbox`` module to
execute each solution in an isolated process with a time limit, which prevents
deadlocks or infinite loops.

The main goal is to determine if solutions generated by the LLM meet the
specification and, in the case of generating more than one, compare their
outputs to detect discrepancies (differential testing).

The design of this module allows its extension to measure code coverage,
execution times or other indicators.  Currently it focuses on checking
functional correctness through simple assertions.
"""

from __future__ import annotations

from typing import Any, Dict, List, Tuple

from .sandbox import run_in_sandbox


def execute_test_case(code: str, test_case: Dict[str, Any], func_name: str = "solve", timeout: float = 2.0) -> Tuple[bool, Any]:
    """Executes a test case on a solution code.

    :param code: Python code that defines a function ``func_name``.
    :param test_case: Dictionary with keys ``input`` and ``expected``.
    :param func_name: Name of the function to invoke.
    :param timeout: Maximum execution time for each case.
    :return: Tuple ``(success, result)``, where ``success`` indicates if the
      execution completed and ``result`` contains the output or traceback.
    """
    input_data = test_case.get("input")
    # Convert input_data to positional arguments
    if isinstance(input_data, list):
        args = tuple(input_data)
    elif input_data is None:
        args = tuple()
    else:
        args = (input_data,)
    return run_in_sandbox(code, func_name, args=args, kwargs={}, timeout=timeout)


def validate_solutions(solutions: List[str], test_cases: List[Dict[str, Any]], func_name: str = "solve", timeout: float = 2.0) -> Dict[str, Any]:
    """Validates multiple solutions against a set of test cases.

    For each solution, all cases are executed and it is recorded whether the
    output matches what is expected.  If multiple solutions are provided,
    a differential check is also performed: outputs are compared between
    different implementations to detect divergences.

    :param solutions: List of strings with Python code.
    :param test_cases: List of test cases.  Each case must include
      ``input`` and ``expected``.
    :param func_name: Name of the function that solutions implement.
    :param timeout: Maximum time per case.
    :return: Dictionary with statistics and detailed results.
    """
    results = {}
    # Execute each combination of solution and test case
    for idx, code in enumerate(solutions):
        sol_key = f"solution_{idx+1}"
        results[sol_key] = {
            "passes": 0,
            "fails": 0,
            "details": []
        }
        for case in test_cases:
            success, output = execute_test_case(code, case, func_name=func_name, timeout=timeout)
            expected = case.get("expected")
            passed = success and output == expected
            results[sol_key]["details"].append({
                "input": case.get("input"),
                "expected": expected,
                "output": output,
                "passed": passed,
            })
            if passed:
                results[sol_key]["passes"] += 1
            else:
                results[sol_key]["fails"] += 1

    # Differential check between solutions
    if len(solutions) > 1:
        diff_results = []
        # We assume solutions return the same data type
        for case in test_cases:
            outputs = []
            for code in solutions:
                success, output = execute_test_case(code, case, func_name=func_name, timeout=timeout)
                outputs.append(output if success else None)
            consistent = all(o == outputs[0] for o in outputs[1:]) if outputs else True
            diff_results.append({
                "input": case.get("input"),
                "outputs": outputs,
                "consistent": consistent,
            })
        results["differential"] = diff_results
    return results